// Code generated by protokitgo. DO NOT EDIT.
// source: common_command/common_cmd.proto

package common_command

import (
	// fixed import by protokitgo
	"context"
	"fmt"
	"math"
	"reflect"
	"strings"

	"bitbucket.org/funplus/ark"
	"bitbucket.org/funplus/sandwich/base/net/link"
	"bitbucket.org/funplus/sandwich/client"
	"bitbucket.org/funplus/sandwich/current"
	"bitbucket.org/funplus/sandwich/message"
	"bitbucket.org/funplus/sandwich/metadata"
	"bitbucket.org/funplus/sandwich/protocol/netutils"
	"bitbucket.org/funplus/sandwich/router"
	"github.com/sandwich-go/boost/validator"
	serror "github.com/sandwich-go/boost/xerror"
	"google.golang.org/protobuf/proto"

	_ "google.golang.org/genproto/googleapis/api/annotations"
	protobufEmpty "google.golang.org/protobuf/types/known/emptypb"
	// dynamic import
)

// Reference imports to suppress errors if they are not otherwise used.
var _ ark.Context
var _ client.Client
var _ router.Router
var _ = current.NewContext(context.Background())
var _ serror.Error
var _ link.Session
var _ message.Message
var _ netutils.RawPacket
var _ ark.Context
var _ context.Context
var _ = fmt.Errorf
var _ = math.Inf
var _ proto.MarshalOptions
var _ reflect.Type
var _ strings.Builder
var _ metadata.MD
var _ protobufEmpty.Empty
var _ validator.Validator

// XXX_QueryPath      : Service 注册到的的 Query Path，请求根路径(目前只适用于HTTP服务)
// XXX_FullMethodName : sandwich 方法 URI
// XXX_FullGRPCName   : GRPC 方法 URI
// XXX_FullPathHTTP   : 请求的HTTP全路径，包含QueryPath部分

var CommonCmdService_QueryPath_Check = true

const (
	CommonCmdService_QueryPath = "/"

	// for method Ping
	CommonCmd_Ping_FullPathHTTP   = "/common_command.CommonCmd/Ping"
	CommonCmd_Ping_FullMethodName = "/common_command.CommonCmd/Ping"
	CommonCmd_Ping_FullGRPCName   = "/common_command.CommonCmd/Ping"
	// CommonCmd_Ping_FullHTTPName
	// Deprecated : 使用 CommonCmd_Ping_FullPathHTTP
	CommonCmd_Ping_FullHTTPName = "/common_command.CommonCmd/Ping"
)

// ServerHandlerCommonCmdForRPC  server handler interface for RPC
type ServerHandlerCommonCmdForRPC interface {
	Ping(ctx context.Context, in *netutils.Ping) (*netutils.PingAck, error)
}

// ServerHandlerCommonCmdForActor  server handler interface for Actor system
type ServerHandlerCommonCmdForActor interface {
}

// ServerHandlerCommonCmd server handler interface
type ServerHandlerCommonCmd interface {
	ServerHandlerCommonCmdForRPC
	ServerHandlerCommonCmdForActor
}

// UnimplementedServerHandlerCommonCmdForRPC  can be embedded to have forward compatible implementations.
type UnimplementedServerHandlerCommonCmdForRPC struct{}

func (*UnimplementedServerHandlerCommonCmd) Ping(ctx context.Context, in *netutils.Ping) (*netutils.PingAck, error) {
	return nil, serror.NewProtoEnum(netutils.ErrorCode_NotImplement)
}

// UnimplementedServerHandlerCommonCmdForActor  can be embedded to have forward compatible implementations.
type UnimplementedServerHandlerCommonCmdForActor struct {
}

// UnimplementedServerHandlerCommonCmd  can be embedded to have forward compatible implementations.
type UnimplementedServerHandlerCommonCmd struct {
	UnimplementedServerHandlerCommonCmdForRPC
	UnimplementedServerHandlerCommonCmdForActor
}

// gen server side proxy
type proxyServerHandlerCommonCmdForRPC struct {
	handler ServerHandlerCommonCmdForRPC
}

// gen server side proxy
type proxyServerHandlerCommonCmdForActor struct {
	handler ServerHandlerCommonCmdForActor
}

func (h *proxyServerHandlerCommonCmdForRPC) proxyPing(ctx context.Context, in interface{}) (interface{}, error) {
	if req, ok := in.(*netutils.Ping); ok {
		return h.handler.Ping(ctx, req)
	} else {
		return nil, serror.NewProtoEnum(netutils.ErrorCode_MessageCastError)
	}
}

// tcp handler
func RegisterServerHandlerCommonCmdForRPCForCommonRouter(r router.Router, s ServerHandlerCommonCmdForRPC) {
	h := &proxyServerHandlerCommonCmdForRPC{handler: s}
	{
		rsp := new(netutils.PingAck)
		r.SetMessageHandler(CommonCmd_Ping_FullMethodName, h.proxyPing)
		// uri mapping
		if s, ok := r.(interface {
			SetURIMapping(interface{}, interface{})
		}); ok {
			s.SetURIMapping(CommonCmd_Ping_FullMethodName, rsp)
		}
	}
}

// tcp handler
func RegisterServerHandlerCommonCmdForActorForCommonRouter(r router.Router, s ServerHandlerCommonCmdForActor) {
}

func RegisterServerHandlerCommonCmdForCommonRouter(r router.Router, s ServerHandlerCommonCmd) {
	RegisterServerHandlerCommonCmdForRPCForCommonRouter(r, s)
	RegisterServerHandlerCommonCmdForActorForCommonRouter(r, s)
}

// http handler
func RegisterServerHandlerCommonCmdForRPCForArk(r ark.Router, s ServerHandlerCommonCmdForRPC) {
	// 校验传入的Router QueryPath是否与service定义时的一致
	if CommonCmdService_QueryPath_Check && r.BasePath() != CommonCmdService_QueryPath {
		panic(fmt.Sprintf("query path:%s not same as defined in proto file:%s", r.BasePath(), CommonCmdService_QueryPath))
	}

	h := &proxyServerHandlerCommonCmdForRPC{handler: s}
	{
		t := new(netutils.Ping)
		m := h.proxyPing
		err := router.RegisterMessageUnder(r, CommonCmd_Ping_FullMethodName, m)

		if err != nil {
			panic(fmt.Errorf("service register failed with RegisterMessageUnder, with message:%v, err:%w", t, err))
		}
		// auto generate by ProtoKitGo
		path := strings.TrimPrefix(CommonCmd_Ping_FullHTTPName, r.BasePath())
		r.GetPost(path, router.ArkCommonHandle(t, m))
	}
}

// http handler
func RegisterServerHandlerCommonCmdForActorForArk(r ark.Router, s ServerHandlerCommonCmdForActor) {
	// 校验传入的Router QueryPath是否与service定义时的一致
	if CommonCmdService_QueryPath_Check && r.BasePath() != CommonCmdService_QueryPath {
		panic(fmt.Sprintf("query path:%s not same as defined in proto file:%s", r.BasePath(), CommonCmdService_QueryPath))
	}

}

func RegisterServerHandlerCommonCmdForArk(r ark.Router, s ServerHandlerCommonCmd) {
	RegisterServerHandlerCommonCmdForRPCForArk(r, s)
	RegisterServerHandlerCommonCmdForActorForArk(r, s)
}

func RegisterServerHandlerCommonCmdForRPC(dst interface{}, handler ServerHandlerCommonCmdForRPC) {
	found := false
	if commonRouter, ok := dst.(router.Router); ok {
		found = true
		RegisterServerHandlerCommonCmdForRPCForCommonRouter(commonRouter, handler)
	}
	if arkRouter, ok := dst.(ark.Router); ok {
		found = true
		RegisterServerHandlerCommonCmdForRPCForArk(arkRouter, handler)
	}
	if !found {
		panic(fmt.Sprintf("got invalid router type:%v", reflect.TypeOf(dst)))
	}
}

func RegisterServerHandlerCommonCmdForActor(dst interface{}, handler ServerHandlerCommonCmdForActor) {
	found := false
	if commonRouter, ok := dst.(router.Router); ok {
		found = true
		RegisterServerHandlerCommonCmdForActorForCommonRouter(commonRouter, handler)
	}
	if arkRouter, ok := dst.(ark.Router); ok {
		found = true
		RegisterServerHandlerCommonCmdForActorForArk(arkRouter, handler)
	}
	if !found {
		panic(fmt.Sprintf("got invalid router type:%v", reflect.TypeOf(dst)))
	}
}

func RegisterServerHandlerCommonCmd(dst interface{}, handler ServerHandlerCommonCmd) {
	found := false
	if commonRouter, ok := dst.(router.Router); ok {
		found = true
		RegisterServerHandlerCommonCmdForCommonRouter(commonRouter, handler)
	}
	if arkRouter, ok := dst.(ark.Router); ok {
		found = true
		RegisterServerHandlerCommonCmdForArk(arkRouter, handler)
	}
	if !found {
		panic(fmt.Sprintf("got invalid router type:%v", reflect.TypeOf(dst)))
	}
}

// Deprecated: use ServerHandlerCommonCmd
type CommonCmdService = ServerHandlerCommonCmd

// Deprecated: use RegisterServerHandlerCommonCmdForArk or RegisterServerHandlerCommonCmd
var RegisterCommonCmdServiceHttpHandler = RegisterServerHandlerCommonCmdForArk

// Deprecated: use RegisterServerHandlerCommonCmdForCommonRouter or RegisterServerHandlerCommonCmd
var RegisterCommonCmdServiceTcpHandler = RegisterServerHandlerCommonCmdForCommonRouter

// rpcProxy将服务内的rpc server转发到Client指定的服务，如Python RPC Server
type rpcProxyServerHandlerCommonCmd struct {
	rpcClient RpcClientCommonCmd
	opts      []client.CallOption
}

func NewServerHandlerCommonCmdWithClient(cc client.Client, opts ...client.CallOption) ServerHandlerCommonCmd {
	return &rpcProxyServerHandlerCommonCmd{rpcClient: NewRpcClientCommonCmd(cc), opts: opts}
}
func (r *rpcProxyServerHandlerCommonCmd) Ping(ctx context.Context, in *netutils.Ping) (*netutils.PingAck, error) {
	return r.rpcClient.Ping(ctx, in, r.opts...)
}
